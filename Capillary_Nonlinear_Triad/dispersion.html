<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Dispersion Relation</title>
    
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
            "HTML-CSS": { scale: 100 }
        });
    </script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_SVG"></script>
    
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    
    <style>
        body { font-family: "Times New Roman", Times, serif; margin: 20px; background-color: #f4f4f4; }
        .container { max-width: 950px; margin: 0 auto; background: white; padding: 25px; box-shadow: 0 0 10px rgba(0,0,0,0.1); border-radius: 8px; }
        
        .controls { 
            margin-top: 25px; 
            padding: 20px; 
            background: #eef; 
            border-radius: 5px; 
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Slider Label Style */
        .slider-label { font-size: 1.25em; margin-right: 15px; }
        
        input[type=range] { width: 300px; cursor: pointer; }
        
        #k0-val { 
            font-weight: bold; 
            font-family: "Courier New", monospace; 
            font-size: 1.25em;
            margin-left: 15px; 
            min-width: 50px;
        }
        
        .caption { 
            margin-top: 20px; 
            font-size: 1.1em;
            line-height: 1.5;
            color: #333; 
            text-align: center;
            padding: 10px;
            background-color: #fafafa;
            border-top: 1px solid #ddd;
        }
    </style>
</head>
<body>

<div class="container">
    <div id="plotDiv" style="width: 100%; height: 650px;"></div>

    <div class="controls">
        <span class="slider-label">Adjust Carrier Wavenumber ($\kappa_0$):</span>
        <input type="range" id="k0Slider" min="0" max="12.5" step="0.1" value="0">
        <span id="k0-val">0.00</span>
    </div>

    <div class="caption">
        <strong>Figure 1:</strong> Graphical construction of the resonance condition for capillary-gravity waves ($\mathrm{Bo} = 100$).<br>
        <span style="color: blue;">Blue Solid:</span> $\Omega(\kappa)$ &nbsp;|&nbsp; 
        <span style="color: red;">Red Dashed:</span> $\Omega(\kappa - \kappa_0) + \Omega(\kappa_0)$ <br>
        The <span style="color: green; font-weight: bold;">Green Circle</span> marks the resonant triad intersection.
    </div>
</div>

<script>
    // --- 1. CONFIGURATION ---
    const Bo = 100.0;
    const kMax = 25.0;
    const numPoints = 1000;
    
    // --- 2. PHYSICS FUNCTIONS ---
    function getOmega(k) {
        if (k < 0) return 0; 
        const termGravity = k;
        const termCapillary = Math.pow(k, 3) / Bo;
        const termDepth = Math.tanh(k);
        return Math.sqrt((termGravity + termCapillary) * termDepth);
    }

    // Generate Base Grid
    const kGrid = [];
    const omegaBase = [];
    for (let i = 0; i <= numPoints; i++) {
        let k = (i / numPoints) * kMax;
        kGrid.push(k);
        omegaBase.push(getOmega(k));
    }

    // --- 3. INITIAL PLOT SETUP ---
    const traceBase = {
        x: kGrid,
        y: omegaBase,
        mode: 'lines',
        name: '$\\Omega(\\kappa)$',
        line: {color: 'blue', width: 3}
    };

    const traceShift = {
        x: [],
        y: [],
        mode: 'lines',
        name: '$\\Omega(\\kappa - \\kappa_0) + \\Omega_0$',
        line: {color: 'red', dash: 'dash', width: 2.5}
    };

    const traceK0 = {
        x: [0],
        y: [0],
        mode: 'markers',
        showlegend: false,
        marker: {color: 'red', size: 12}
    };

    const traceInt = {
        x: [],
        y: [],
        mode: 'markers',
        name: 'Intersection',
        marker: {color: 'green', size: 14, line: {color: 'black', width: 1.5}}
    };

    const layout = {
        title: {
            text: '$\\textbf{Dispersion Relation } (\\mathrm{Bo} = 100)$',
            font: {size: 28} 
        },
        xaxis: {
            title: {
                text: '$\\kappa$',
                font: {size: 24} // Larger Axis Title
            },
            tickfont: {size: 18}, // Larger Numbers
            range: [0, kMax],
            zeroline: true
        },
        yaxis: {
            title: {
                text: '$\\Omega$',
                font: {size: 24} // Larger Axis Title
            },
            tickfont: {size: 18}, // Larger Numbers
            range: [0, Math.max(...omegaBase) * 1.05],
            zeroline: true
        },
        legend: {
            x: 0.02, 
            y: 0.98,
            font: {size: 16}
        },
        margin: {l: 70, r: 30, t: 60, b: 60}, // Add space for larger labels
        hovermode: 'closest'
    };

    const config = {responsive: true};

    Plotly.newPlot('plotDiv', [traceBase, traceShift, traceK0, traceInt], layout, config).then(function() {
        // Force MathJax to render the HTML text (Slider/Caption)
        if (window.MathJax) {
            MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
        }
    });

    // --- 4. INTERACTIVITY ---

    const slider = document.getElementById('k0Slider');
    const valDisplay = document.getElementById('k0-val');

    slider.addEventListener('input', function() {
        updatePlot(parseFloat(this.value));
    });

    function updatePlot(k0) {
        valDisplay.textContent = k0.toFixed(2);
        
        const w0 = getOmega(k0);
        const updateK0 = { x: [[k0]], y: [[w0]] };

        // --- Calculate Shifted Curve ---
        const xLocal = [];
        const yShifted = [];
        
        let startIdx = Math.floor((k0 / kMax) * numPoints);
        
        for(let i = startIdx; i < numPoints; i++) {
            let k = kGrid[i];
            if(k < k0) continue; 
            
            let k_input = k - k0;
            let w_local = getOmega(k_input);
            let w_shift = w_local + w0;
            
            xLocal.push(k);
            yShifted.push(w_shift);
        }

        const updateShift = { x: [xLocal], y: [yShifted] };

        // --- Find Intersection ---
        let intX = null;
        let intY = null;

        for (let j = 0; j < xLocal.length - 1; j++) {
            let globalIdx = Math.round((xLocal[j] / kMax) * numPoints);
            if (globalIdx >= omegaBase.length - 1) break;

            let yBase1 = omegaBase[globalIdx];
            let yBase2 = omegaBase[globalIdx + 1];
            let yShift1 = yShifted[j];
            let yShift2 = yShifted[j + 1];
            let diff1 = yBase1 - yShift1;
            let diff2 = yBase2 - yShift2;

            if (diff1 * diff2 <= 0) {
                if (xLocal[j] > k0 + 0.1) {
                    let fraction = Math.abs(diff1) / (Math.abs(diff1) + Math.abs(diff2) + 1e-12);
                    let x1 = xLocal[j];
                    let x2 = xLocal[j+1];
                    intX = x1 + fraction * (x2 - x1);
                    intY = yBase1 + fraction * (yBase2 - yBase1);
                    break; 
                }
            }
        }

        const updateInt = {
            x: intX !== null ? [[intX]] : [[]],
            y: intY !== null ? [[intY]] : [[]]
        };

        Plotly.restyle('plotDiv', updateShift, [1]);
        Plotly.restyle('plotDiv', updateK0, [2]);
        Plotly.restyle('plotDiv', updateInt, [3]);
    }
</script>

</body>
</html>